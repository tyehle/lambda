;; Base file defining most of the functions of the language

;; Useful Functions

(type id (forall a (-> a a)))
(define (id x) x)

(type const (forall (a b) (-> a b a)))
(define (const x _) x)

(type hang (forall a a))
(define hang ((λ (u) (u u)) (λ (u) (u u))))


;; Booleans

;(struct Bool
;  [#t]
;  [#f])

(type #f Bool)
(define (#f f t) f)

(type #t Bool)
(define (#t f t) t)

(type if (forall a (-> Bool a a a)))
(define (if c t f)
  (c f t))

(type and (-> Bool Bool Bool))
(define (and a b)
  (if a b #f))

(type or (-> Bool Bool Bool))
(define (or a b)
  (if a #t b))

(type not (-> Bool Bool))
(define (not a)
  (if a #f #t))


;; Numbers

;(type-synonym (∀ a (Num a)) (-> (-> a a) a a))
;(type-def (∀ a (Num a)) (-> (-> a a) a a))

(type zero? (-> Num Bool))
(define (zero? n) (n (const #f) #t))

(type succ (-> Num Num))
(define (succ n) (λ (f x) (f (n f x))))

(type prev (-> Num Num))
(define (prev n)
  (λ (f x) (n (λ (g h) (h (g f)))
              (const x)
              id)))

(type + (-> Num Num Num))
(define (+ a b) (λ (f x) ((a f) (b f x))))

(type * (-> Num Num Num))
(define (* a b) (λ (f) (a (b f))))

(type - (-> Num Num Num))
(define (- a b) (b prev a))

(type / (-> Num Num Num))
(define (/ n m)
  (letrec (div1 (λ (n1 m1)
                  (let ([diff (- n1 m1)])
                    (if (zero? diff)
                        0
                        (succ (div1 diff m1))))))
    (div1 (succ n) m)))

(type = (-> Num Num Bool))
(define (= a b) (and (zero? (- a b)) (zero? (- b a))))

(type even? (-> Num Bool))
(define (even? n) (n not #t))

(type mod (-> Num Num Num))
(define (mod n m)
  (letrec (mod1 (λ (n1 m1)
                  (let ([diff (- n1 m1)])
                    (if (zero? diff)
                        n1
                        (mod1 diff m1)))))
    (prev (mod1 (succ n) m))))

(type <= (-> Num Num Bool))
(define (<= a b)
  (zero? (- a b)))

(type >= (-> Num Num Bool))
(define (>= a b)
  (zero? (- b a)))

(type < (-> Num Num Bool))
(define (< a b)
  (<= (+ 1 a) b))

(type > (-> Num Num Bool))
(define (> a b)
  (>= a (+ 1 b)))


;; Lists

; Special syntax [a] is internally changed to (List a)?
;(struct (∀ a (List a))
;  [Cons a (List a)]
;  [Empty])

(type Cons (∀ a [a]))
(define (Cons h t) (λ (c e) (c h t)))

(type Empty (∀ a [a]))
(define Empty (λ (c e) e))


(type head (∀ a (-> [a] a)))
(define (head l)
  (l (λ (h t) h) hang))

(type tail (∀ a (-> [a] [a])))
(define (tail l)
  (l (λ (h t) t) hang))

(type null? (∀ a (-> [a] Bool)))
(define (null? l)
  (l (λ (_ _) #f) #t))

(type pair? (∀ a (-> [a] Bool)))
(define (pair? l)
  (not (null? l)))

(type foldl (∀ (a b) (-> (-> b a b) b [a] b)))
(define (foldl fn acc xs)
  (xs (λ (h t) (foldl fn (fn acc h) t))
      acc))

(type foldr (∀ (a b) (-> (-> a b b) b [a] b)))
(define (foldr fn acc xs)
  (xs (λ (h t) (fn h (foldr fn acc t)))
      acc))

(type map (∀ (a b) (-> (-> a b) [a] [b])))
(define (map f xs)
  (xs (λ (h t) (Cons (f h) (map f t)))
      Empty))

(type take (∀ a (-> Num [a] [a])))
(define (take n l)
  (l (λ (h t) (if (zero? n)
                  Empty
                  (Cons h (take (prev n) t))))
     Empty))

(type from (-> Num [Num]))
(define (from n)
  (Cons n (from (succ n))))

(type range (-> Num Num [Num]))
(define (range low high)
  (if (>= low high)
      Empty
      (Cons low
            (range (+ 1 low)
                   high))))
