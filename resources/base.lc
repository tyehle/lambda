;; Base file defining most of the functions of the language

;; Useful Functions

(type id (-> a a))
(define (id x) x)

(type const (-> a b a))
(define (const x _) x)

(type hang a)
(define hang hang)


;; Booleans

(struct Bool
  [#t]
  [#f])

(type if (-> Bool a a a))
(define (if c t f)
  (case c
    [#t t]
    [#f f]))

(type and (-> Bool Bool Bool))
(define (and a b)
  (if a b #f))

(type or (-> Bool Bool Bool))
(define (or a b)
  (if a #t b))

(type not (-> Bool Bool))
(define (not a)
  (if a #f #t))


;; Numbers

(type zero? (-> Num Bool))
(define (zero? n) (n (const #f) #t))

(type succ (-> Num Num))
(define (succ n) (λ (f x) (f (n f x))))

(type prev (-> Num Num))
(define (prev n)
  (λ (f x) (n (λ (g h) (h (g f)))
              (const x)
              id)))

(type + (-> Num Num Num))
(define (+ a b) (λ (f x) ((a f) (b f x))))

(type * (-> Num Num Num))
(define (* a b) (λ (f) (a (b f))))

(type - (-> Num Num Num))
(define (- a b) (b prev a))

(type / (-> Num Num Num))
(define (/ n m)
  (letrec (div1 (λ (n1 m1)
                  (let ([diff (- n1 m1)])
                    (if (zero? diff)
                        0
                        (succ (div1 diff m1))))))
    (div1 (succ n) m)))

(type = (-> Num Num Bool))
(define (= a b) (and (zero? (- a b)) (zero? (- b a))))

(type even? (-> Num Bool))
(define (even? n) (n not #t))

(type mod (-> Num Num Num))
(define (mod n m)
  (letrec (mod1 (λ (n1 m1)
                  (let ([diff (- n1 m1)])
                    (if (zero? diff)
                        n1
                        (mod1 diff m1)))))
    (prev (mod1 (succ n) m))))

(type <= (-> Num Num Bool))
(define (<= a b)
  (zero? (- a b)))

(type >= (-> Num Num Bool))
(define (>= a b)
  (zero? (- b a)))

(type < (-> Num Num Bool))
(define (< a b)
  (<= (+ 1 a) b))

(type > (-> Num Num Bool))
(define (> a b)
  (>= a (+ 1 b)))


;; Lists

; Special syntax [a] is internally changed to (List a)
(struct (∀ a [a])
  [Cons a [a]]
  [Empty])

(type head (-> [a] a))
(define (head l)
  (case l
    [(Cons h t) h]
    [Empty hang]))

(type tail (-> [a] [a]))
(define (tail l)
  (case l
    [(Cons h t) t]
    [Empty hang]))

(type null? (-> [a] Bool))
(define (null? l)
  (case l
    [(Cons _ _) #f]
    [Empty #t]))

(type pair? (-> [a] Bool))
(define (pair? l)
  (not (null? l)))

(type foldl (-> (-> b a b) b [a] b))
(define (foldl fn acc xs)
  (case xs
    [(Cons h t) (foldl fn (fn acc h) t)]
    [Empty acc]))

(type foldr (-> (-> a b b) b [a] b))
(define (foldr fn acc xs)
  (case xs
    [(Cons h t) (fn h (foldr fn acc t))]
    [Empty acc]))

(type map (-> (-> a b) [a] [b]))
(define (map f xs)
  (case xs
    [(Cons h t) (Cons (f h) (map f t))]
    [Empty Empty]))

(type take (-> Num [a] [a]))
(define (take n l)
  (case l
    [Empty Empty]
    [(Cons h t) (if (zero? n)
                    Empty
                    (Cons h (take (prev n) t)))]))

(type from (-> Num [Num]))
(define (from n)
  (Cons n (from (succ n))))

(type range (-> Num Num [Num]))
(define (range low high)
  (if (>= low high)
      Empty
      (Cons low
            (range (+ 1 low)
                   high))))
